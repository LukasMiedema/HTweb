<?php

namespace Sessions;

class Auth_SessionContext extends \Auth_Context{
	
	/**
	 * Context user. By default the current user.
	 * @var \Auth\Model_User 
	 */
	private $user;
	
	/**
	 * Context session.
	 * @var \Sessions\Model_Session
	 */
	private $session;
	
	/* Grace variables */
	const DEADLINE_GRACE = '+19hours';
	const ENROLLMENT_GRACE = '+5days';
	const COST_GRACE = '+5days';
	const DISHWASHER_ENROLLMENT_GRACE = '+1day';

	const DINER_TIME = '18:00';
	
	public function __construct(\Sessions\Model_Session $session, \Auth\Model_User $user=null) {
		if(empty($user)) {
			$user = \Auth::get_user();
		}
		
		if(empty($session)) {
			throw new \InvalidArgumentException('Session may be null when constructing context.');
		}
		
		$this->user = $user;
		$this->session = $session;
	}
	/**
	 * Session CRUD permission evaluation
	 * @param int $perm from \Auth_PermissionType
	 * @return boolean
	 * @throws \InvalidArgumentException
	 */
	public function can_session(int $perm) {
		if(!\Auth_PermissionType::isValidValue($perm)) {
			throw new \InvalidArgumentException($perm + ' is not a valid permission type.');
		}
		
		if($this->session->settled) {
			return false;
		}
		
		if(\Auth::has_access('sessions.management')) {
			return true;
		} 
		
		switch($perm) {
			case \Auth_PermissionType::CREATE:	
				return false; // Session are generated by the system
			case \Auth_PermissionType::READ:
				return true;
			case \Auth_PermissionType::UPDATE:
				return $this->_can_session_update();
			case \Auth_PermissionType::DELETE:
				return false; // Only session mods
		}
	}
	
	/**
	 * Check if able to update session
	 * @return boolean
	 */
	private function _can_session_update() {
		if ($this->_in_enroll_period() || $this->_in_enroll_mod_grace()) {
			return $this->_is_cook();
		} 
		return false;
	}
	
	/**
	 * Enrollment CRUD permission evaluation
	 * @param int $perm from \Auth_PermissionType
	 * @return boolean
	 * @throws \InvalidArgumentException
	 */
	public function can_enrollment(int $perm, int $user_id=null) {
		if(!\Auth_PermissionType::isValidValue($perm)) {
			throw new \InvalidArgumentException($perm + ' is not a valid permission type.');
		}
		
		if($this->session->settled) {
			return false;
		}
		
		if(\Auth::has_access('sessions.management')) {
			return true;
		} 
	
		switch($perm) {
			case \Auth_PermissionType::CREATE:	
			case \Auth_PermissionType::DELETE:
				return $this->_can_enrollment_create($user_id);
			case \Auth_PermissionType::READ:
				return true;
			case \Auth_PermissionType::UPDATE:
				return $this->_can_enrollment_update($user_id);
		}
	}
	
	/**
	 * Check if able to create enrollment
	 * @param int $user_id User for which we want to update enrollment
	 * @return boolean
	 */
	private function _can_enrollment_create($user_id) {
		if($this->_in_enroll_period()) { 
			if($user_id == $this->user->id) {
				return true; // My enrollment
			} 
		} else if ($this->_in_enroll_mod_grace()) {
			return $this->_is_cook();
		}
		return false;		
	}
	
	/**
	 * Check if able to update enrollment
	 * @param int $user_id User for which we want to update enrollment
	 * @return boolean
	 */
	private function _can_enrollment_update($user_id) {
		if($this->_in_enroll_period()) { 
			if($user_id == $this->user->id) {
				return true; // My enrollment
			}						
		} else if ($this->_in_enroll_mod_grace()) {
			return $this->_is_cook();
		} else if ($this->_in_dishwasher_grace()) {
			return true;
		}
		return false;		
	}
	
	/**
	 * Session UI visibility evaluation
	 * @param int $ui_item_id from Auth_SessionUIItem
	 * @return boolean
	 * @throws \InvalidArgumentException
	 */
	public function canview_session($ui_item_id) {
		if(!Auth_SessionUIItem::isValidValue($ui_item_id)) {
			throw new \InvalidArgumentException($ui_item_id + ' is not a valid ui item.');
		}
		
		$cur_enrollment = $this->session->get_enrollment($this->user->id);
		
		switch($ui_item_id) {
			case Auth_SessionUIItem::BTN_ENROLL:
				return $this->_in_enroll_period() && empty($cur_enrollment);
			case Auth_SessionUIItem::BTN_UNROLL:
				return $this->_in_enroll_period() && isset($cur_enrollment);
			case Auth_SessionUIItem::BTN_ENROLL_DISHWASHER:
				return $this->_in_dishwasher_grace() && isset($cur_enrollment); // MORE!
			case Auth_SessionUIItem::COLUMN_ACTIONS:
			case Auth_SessionUIItem::BTN_ENROLL_ADD:
				return $this->_in_enroll_mod_grace() && $this->_is_cook();
			case Auth_SessionUIItem::BTN_SESSION_UPDATE:
				return $this->_is_cook() && ($this->_in_enroll_period() || $this->_in_enroll_mod_grace());
			case Auth_SessionUIItem::INPUT_DEADLINE:
			case Auth_SessionUIItem::INPUT_COST:
			case Auth_SessionUIItem::INPUT_PAYER_SELECT:
				return false;
			case Auth_SessionUIItem::ALERT_DEADLINE_CHANGED:
				return $this->_in_enroll_period() && (\Sessions\Model_Session::DEADLINE_TIME != (new \DateTime($this->session->deadline))->format('H:i'));
		}
		
	}
	
	private function _is_cook() {
		$cur_enrollment = $this->session->get_enrollment($this->user->id);
		if(isset($cur_enrollment)) {
			return $cur_enrollment->cook;
		}
		return false;
	}
	
	/**
	 * Check if in enrollment period (< session-deadline)
	 * @return boolean
	 */
	private function _in_enroll_period() {
		$now = strtotime(date('Y-m-d H:i:s'));
		$deadline = strtotime(date('Y-m-d H:i:s', strtotime($this->session->deadline)));	
		// Check if we live before the deadline
		if ($now < $deadline) {
			return true;
		} else {
			return false;
		}
	}
	
	/**
	 * Check if cook can update/create enrollments (< session-date + 4days)
	 * @return boolean
	 */
	private function _in_enroll_mod_grace() {
		return !$this->_in_enroll_period() && (strtotime(date('Y-m-d H:i:s')) < strtotime($this->session->date . static::ENROLLMENT_GRACE));
	}
	
	/**
	 * Determine if dishwashers may enroll for this session. Sets both upper and lower boundary.
	 * @return boolean
	 */
	private function _in_dishwasher_grace() {
		return !$this->_in_enroll_period() && $this->_in_past_diner() && strtotime(date('Y-m-d H:i:s')) < strtotime($this->session->date . static::DISHWASHER_ENROLLMENT_GRACE);
	}
	
	/**
	 * Determine if we're past diner time (by default diner time is at 18:00)
	 * @return boolean
	 */
	private function _in_past_diner() {
		$now = strtotime(date('Y-m-d H:i:s'));
		$begin = strtotime(date('Y-m-d H:i:s', strtotime(static::DINER_TIME)));	
		// Now should be after diner start
		if ($now > $begin) {
			return true;
		} else {
			return false;
		}
	}
}
