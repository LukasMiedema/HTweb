<?php

namespace Sessions;

class Auth_SessionContext extends \Auth_Context{
	
	/**
	 * Context user. By default the current user.
	 * @var \Auth\Model_User 
	 */
	private $user;
	
	/**
	 * Context session.
	 * @var \Sessions\Model_Session
	 */
	private $session;
	
	/* Grace variables */
	const DEADLINE_GRACE = '+19hours';
	const ENROLLMENT_GRACE = '+5days';
	const COST_GRACE = '+5days';
	const DISHWASHER_ENROLLMENT_GRACE = '+1day';

	const DINER_TIME = '18:00';
	
	public function __construct(\Sessions\Model_Session $session, \Auth\Model_User $user=null) {
		if(empty($user)) {
			$user = \Auth::get_user();
		}
		
		if(empty($session)) {
			throw new \InvalidArgumentException('Session may be null when constructing context.');
		}
		
		$this->user = $user;
		$this->session = $session;
	}
	
	public static function forge(\Sessions\Model_Session $session, \Auth\Model_User $user=null) {
		return new Auth_SessionContext($session, $user);
	}
	/**
	 * Session CRUD permission evaluation
	 * @param int $perm from \Auth_PermissionType
	 * @return boolean
	 * @throws \InvalidArgumentException
	 */
	public function can_session(int $perm) {
		if(!\Auth_PermissionType::isValidValue($perm)) {
			throw new \InvalidArgumentException($perm + ' is not a valid permission type.');
		}
		
		if($this->session->settled) {
			return false;
		}
		
		if(\Auth::has_access('sessions.management')) {
			return true;
		} 
		
		switch($perm) {
			case \Auth_PermissionType::CREATE:	
				return false; // Session are generated by the system
			case \Auth_PermissionType::READ:
				return true;
			case \Auth_PermissionType::UPDATE:
				return $this->_can_session_update();
			case \Auth_PermissionType::DELETE:
				return false; // Only session mods
		}
	}
	
	/**
	 * Check if able to update session
	 * @return boolean
	 */
	private function _can_session_update() {
		if ($this->_in_enroll_period() || $this->_in_enroll_mod_grace()) {
			return $this->_is_cook();
		} 
		return false;
	}
	
	/**
	 * Enrollment CRUD permission evaluation
	 * @param int $perm from \Auth_PermissionType
	 * @return boolean
	 * @throws \InvalidArgumentException
	 */
	public function can_enrollment(int $perm, int $user_id=null) {
		if(!\Auth_PermissionType::isValidValue($perm)) {
			throw new \InvalidArgumentException($perm + ' is not a valid permission type.');
		}
		
		if($this->session->settled) {
			return false;
		}
		
		if(\Auth::has_access('sessions.management')) {
			return true;
		} 
	
		switch($perm) {
			case \Auth_PermissionType::CREATE:	
			case \Auth_PermissionType::DELETE:
				return $this->_can_enrollment_create($user_id);
			case \Auth_PermissionType::READ:
				return true;
			case \Auth_PermissionType::UPDATE:
				return $this->_can_enrollment_update($user_id);
		}
	}
	
	/**
	 * Check if able to create enrollment
	 * @param int $user_id User for which we want to update enrollment
	 * @return boolean
	 */
	private function _can_enrollment_create($user_id) {
		/**
		 * Permission was simplified to allow cook to enroll anyone 
		 * at any time during enroll and mod grace
		 */
		if($this->_in_enroll_period()) { 
			if($user_id == $this->user->id) {
				return true; // My enrollment
			} else {
				return $this->_is_cook();
			}
		} else if ($this->_in_enroll_mod_grace()) {
			return $this->_is_cook();
		}
		return false;		
	}
	
	/**
	 * Check if able to update enrollment
	 * @param int $user_id User for which we want to update enrollment
	 * @return boolean
	 */
	private function _can_enrollment_update($user_id) {
		/**
		 * Permission was simplified to allow cook to enroll anyone 
		 * at any time during enroll and mod grace
		 */
		if($this->_in_enroll_period()) { 
			if($user_id == $this->user->id) {
				return true; // My enrollment
			} else {
				return $this->_is_cook();
			}					
		} else if ($this->_in_dishwasher_grace()) {
			return true;
		} else if ($this->_in_enroll_mod_grace()) {
			return $this->_is_cook();
		}
		return false;
	}
	
	/**
	 * Determines if the session can be delayed (e.g. alter deadline).
	 * For a delay to be possible, there should be at least 1 participant.
	 * @return boolean
	 */
	public function can_delay() {
		// The deadline must be past-due and there should be 0 cooks
		if ($this->session->count_participants() > 0) {
			return !$this->_in_enroll_period() && 
				($this->session->count_cooks() == 0) && 
				$this->_in_deadline_mod_grace();
		} else {
			return false;
		}
	}
	
	/**
	 * Session UI visibility evaluation
	 * @param int $ui_item_id from Auth_SessionUIItem
	 * @return boolean
	 * @throws \InvalidArgumentException
	 */
	public function canview_session($ui_item_id) {
		if(!Auth_SessionUIItem::isValidValue($ui_item_id)) {
			throw new \InvalidArgumentException($ui_item_id + ' is not a valid ui item.');
		}
		
		$cur_enrollment = $this->session->get_enrollment($this->user->id);
		
		switch($ui_item_id) {
			case Auth_SessionUIItem::BTN_ENROLL:
				return $this->_in_enroll_period() && empty($cur_enrollment);
			case Auth_SessionUIItem::BTN_UNROLL:
				return $this->_in_enroll_period() && isset($cur_enrollment);
			case Auth_SessionUIItem::BTN_ENROLL_DISHWASHER:
				return $this->_in_dishwasher_grace() && isset($cur_enrollment); // MORE!
			case Auth_SessionUIItem::COLUMN_ACTIONS:
			case Auth_SessionUIItem::BTN_ENROLL_ADD:
				return $this->_is_cook();
			case Auth_SessionUIItem::BTN_SESSION_UPDATE:
				return $this->_is_cook() && ($this->_in_enroll_period() || $this->_in_enroll_mod_grace());
			case Auth_SessionUIItem::INPUT_DEADLINE:
				return $this->canview_session(3) && $this->_in_deadline_mod_grace();
			case Auth_SessionUIItem::INPUT_COST:
				return $this->canview_session(3) && $this->_in_cost_mod_grace();
			case Auth_SessionUIItem::INPUT_PAYER_SELECT:
				return false; // Generally only for administration purposes
			case Auth_SessionUIItem::ALERT_DEADLINE_CHANGED:
				return $this->_in_enroll_period() && (\Sessions\Model_Session::DEADLINE_TIME != (new \DateTime($this->session->deadline))->format('H:i'));
		}	
	}
	
	private function _is_cook() {
		$cur_enrollment = $this->session->get_enrollment($this->user->id);
		if(isset($cur_enrollment)) {
			return $cur_enrollment->cook;
		}
		return false;
	}
	
	/**
	 * Check if in enrollment period (< session-deadline)
	 * @return boolean
	 */
	private function _in_enroll_period() {
		$now = strtotime(date('Y-m-d H:i:s'));
		$deadline = strtotime(date('Y-m-d H:i:s', strtotime($this->session->deadline)));	
		// Check if we live before the deadline
		if ($now < $deadline) {
			return true;
		} else {
			return false;
		}
	}
	
	/**
	 * Check if cook can update/create enrollments (< session-date + 4days)
	 * @return boolean
	 */
	private function _in_enroll_mod_grace() {
		return !$this->_in_enroll_period() && (strtotime(date('Y-m-d H:i:s')) < strtotime($this->session->date . static::ENROLLMENT_GRACE));
	}
	
	/**
	 * Determine if dishwashers may enroll for this session. Sets both upper and lower boundary.
	 * @return boolean
	 */
	private function _in_dishwasher_grace() {
		return !$this->_in_enroll_period() && $this->_in_past_diner() && strtotime(date('Y-m-d H:i:s')) < strtotime($this->session->date . static::DISHWASHER_ENROLLMENT_GRACE);
	}
	
	/**
	 * Determine whether the cost of this session may be changed by the cooks
	 * @return boolean
	 */
	private function _in_cost_mod_grace() {
		return !$this->_in_enroll_period() && (strtotime(date('Y-m-d H:i:s')) < strtotime($this->session->date . static::COST_GRACE));
	}
	
	/**
	 * Determine if we're past diner time (by default diner time is at 18:00)
	 * @return boolean
	 */
	private function _in_past_diner() {
		$now = strtotime(date('Y-m-d H:i:s'));
		$begin = strtotime(date('Y-m-d H:i:s', strtotime(static::DINER_TIME)));	
		// Now should be after diner start
		if ($now > $begin) {
			return true;
		} else {
			return false;
		}
	}
	
	/**
	 * Determine whether the deadline of this session may changed. Sets both upper and lower boundary.
	 * @return boolean
	 */
	private function _in_deadline_mod_grace() {
		if ($this->_in_enroll_period()) { 
			// Deadline may be changed during enrollment period just alright.
			return true;
		} else {
			// If the deadline already passed
			return strtotime(date('Y-m-d H:i:s')) < strtotime($this->session->date . static::DEADLINE_GRACE);
		}
	}
}
